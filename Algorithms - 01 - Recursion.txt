ğŸ¬ Algorithms: Recursion

Recursion is a concept, not a data structure nor an algorithm, but a way that we solve a problem.

recursion is just a way of taking a problem and breaking it down into subproblems and then each of those subproblems is generally broken down into more and more and more sub problems.



This implementation Fibonacci can get very inefficient. Now there's two things to know here. One is there is a way of optimizing this using a technique called memorization and we'll cover that in a different section.


anything that is in implemented recursively can be implemented iteratively.

The reason why we often use recursion is that for certain problems the recursive implementation is a lot easier to read and understand and write than interactive explanation. Doesn't mean that we always want to use recursion or we always want to use iteration, it really just depends on the problem. 


So this means for you and your interview is it's very much a case-by-case decision. Sometimes you want to implement the iterative solution and other times you want to implement the recursive solution. But generally your interviewer will be in there in the room with you and so you don't have to decide by yourself, you can ask your interviewer. 


Recursion is a super popular topic for interviews so I really encourage you to spend a lot of time really


ğŸ¬ Recursion

A recursive function is defined as a function that calls itself as part of its execution.






This idea, this generalization of the problem, allows us to recursively define the factorial function.




The second part is the recursive case. And this is where the recursion will actually take place. This is where the function will call itself.

It won't call itself in exactly the same way it was called. It'll be a slight variation that makes the problem it's trying to solve a teeny bit smaller. But it generally passes the buck of solving the bulk of the solution to a different call down the line.
    
    
    
    
    
    
    
    
    
    
    
    
    defÂ fact(n):
    Â Â #Â DefineÂ baseÂ caseÂ nÂ isÂ 1
    Â Â ifÂ nÂ ==Â 1:
    Â Â Â Â returnÂ 1
    Â Â #Â DefineÂ recursiveÂ caseÂ nÂ !=Â 1
    Â Â #Â LoopÂ whileÂ NÂ >Â 1,Â keepÂ multiplyingÂ thatÂ productÂ nÂ andÂ 
    Â Â #Â decrementingÂ (graduallyÂ decrease)Â thatÂ product
    Â Â else:
    Â Â Â Â returnÂ n*fact(n-1)
    
    
    
    

It is possible to have more than one base case, or have more than one recursive case:

    
    
    
    
    
    
    
    #Â ğŸ§Â theÂ trickÂ aboutÂ recursionÂ isÂ toÂ placeÂ yourÂ funcÂ insideÂ yourÂ func!
    #Â ItÂ mayÂ seemÂ counter-intuitionÂ atÂ first,Â tryÂ toÂ getÂ useÂ toÂ it
    defÂ cc(n):
    Â Â #Â DefineÂ baseÂ case
    Â Â ifÂ nÂ ==Â 1:
    Â Â Â Â returnÂ 0
    Â Â #Â IfÂ nÂ isÂ evenÂ number,Â repeatÂ thisÂ processÂ onÂ n/2
    Â Â elifÂ nÂ %Â 2Â ==Â 0:
    Â Â Â Â returnÂ 1Â +Â cc(n/2)
    Â Â #Â ğŸ‘€Â TheÂ FINALÂ conditionÂ shouldÂ beÂ elseÂ toÂ beÂ comprehensive
    Â Â #Â DOÂ NOTÂ PlaceÂ elifÂ inÂ theÂ end
    Â Â else:
    Â Â Â Â returnÂ 1Â +Â cc(3*nÂ +Â 1)
    Â Â #Â IfÂ nÂ isÂ oddÂ number,Â repeatÂ thisÂ processÂ onÂ 3nÂ +Â 1
    Â Â #Â elifÂ nÂ %Â 2Â ==Â 0:
    Â Â #Â Â Â returnÂ 1Â +Â cc(3*nÂ +Â 1)
